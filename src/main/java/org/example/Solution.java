package org.example;

public class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode previous = null;
        ListNode current = head;
        while (current != null) {
            ListNode next = current.next;
            current.next = previous;

            previous = current; //Теперь сдвигаем предыдущий и текущий элементы
            current = next;
        }
        return previous;
    }
}
/*
 Код решает задачу инвертирования (разворота) связного списка.

 Связный список - это структура данных, состоящая из узлов, каждый из которых содержит данные и ссылку
 на следующий узел в списке.

 Представьте, что у нас есть список узлов A -> B -> C -> D. Каждый узел содержит данные
 (например, число или строку) и ссылку на следующий узел в списке.

 Идея решения состоит в том, чтобы обойти список узлов, начиная с первого узла (головы списка)
 и менять ссылки на следующие узлы, чтобы они указывали на предыдущие узлы, а не на следующие.
 Таким образом, после обхода всего списка, последний узел (который изначально был "концом" списка)
 станет новой головой списка, а первый узел (который изначально был "началом" списка) станет последним узлом.

 В коде это реализуется следующим образом: мы создаем три указателя (т.е. переменные, которые хранят ссылки
 на узлы). Первый указатель prev будет использоваться для хранения ссылки на предыдущий узел в списке,
 второй указатель curr - для хранения ссылки на текущий узел, а третий указатель next - для хранения ссылки
 на следующий узел.

 Сначала мы устанавливаем prev и next на null, а curr - на голову списка.
 Затем мы проходим по всем узлам списка в цикле, каждый раз обновляя ссылки узлов таким образом,
 чтобы они указывали на предыдущие узлы.

 Таким образом, мы сохраняем ссылку на следующий узел в next, затем меняем ссылку текущего узла на prev
 (т.е. предыдущий узел), и затем обновляем prev и curr, чтобы перейти к следующему узлу в списке.

 После прохода всего списка, prev будет ссылаться на последний узел, а curr будет null,
 так как мы прошли до конца списка и достигли null. В этот момент мы возвращаем prev,
 который теперь является головой нового, инвертированного списка.
 */